(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{354:function(a,e,t){a.exports=t.p+"assets/img/init.f1836dec.jpg"},355:function(a,e,t){a.exports=t.p+"assets/img/update.70627b90.jpg"},390:function(a,e,t){"use strict";t.r(e);var r=t(42),o=Object(r.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"初始化项目"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始化项目"}},[a._v("#")]),a._v(" 初始化项目")]),a._v(" "),r("blockquote",[r("p",[a._v("『Composer 一统天下的时代已经到来！』——白岩松")])]),a._v(" "),r("p",[a._v("“一个时代结束了，另一个时代开始了。”")]),a._v(" "),r("p",[a._v("Framework Interoperability Group（框架可互用性小组），简称 FIG，成立于 2009 年。FIG 最初由几位知名 PHP 框架开发者发起，在吸纳了许多优秀的大脑和强健的体魄后，提出了 PSR-0 到 PSR-4 五套 PHP 非官方规范：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("PSR-0 (Autoloading Standard) 自动加载标准")])]),a._v(" "),r("li",[r("p",[a._v("PSR-1 (Basic Coding Standard) 基础编码标准")])]),a._v(" "),r("li",[r("p",[a._v("PSR-2 (Coding Style Guide) 编码风格向导")])]),a._v(" "),r("li",[r("p",[a._v("PSR-3 (Logger Interface) 日志接口")])]),a._v(" "),r("li",[r("p",[a._v("PSR-4 (Improved Autoloading) 自动加载优化标准")])])]),a._v(" "),r("p",[a._v("之后，在此标准之上，Composer 横空出世！Composer 利用 PSR-0 和 PSR-4 以及 PHP5.3 的命名空间构造了一个繁荣的 PHP 生态系统。Composer 类似著名的 npm 和 RubyGems，给海量 PHP 包提供了一个异常方便的协作通道，Composer Hub 地址："),r("a",{attrs:{href:"https://packagist.org/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://packagist.org/"),r("OutboundLink")],1),a._v("。Composer 中文网站："),r("a",{attrs:{href:"http://www.phpcomposer.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://www.phpcomposer.com/"),r("OutboundLink")],1),a._v("。")]),a._v(" "),r("p",[a._v("目前 PHP 界风头正劲的 Laravel 和 Symfony 均直接基于 Composer，大家耳熟能详著名框架 CI 和 Yii 的正开发版本 CodeIgniter 3 和 Yii 2 也都基于 Composer（更新：北京时间2014年10月13日 Yii 2 已经发布）。Composer 就是 PHP 框架的未来，有了它，让 CI 的路由和 Laravel 的 Eloquent ORM 协作就会变的非常简单。")]),a._v(" "),r("p",[a._v("PHP 语言本身就带有强大的网络功能、文件管理功能和丰富的系统 API，Composer 也只是一段 PHP 脚本而已。可以使用")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("php composer.phar update\n")])])]),r("p",[a._v("在合适的地方新建一个文件夹，命名为 MFFC（My First Framework based on Composer），在文件夹下新建文件 composer.json：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('{\n  "require": {\n  }\n}\n')])])]),r("p",[a._v("命令行切换到 MFFC 目录下，运行：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("composer update\n")])])]),r("p",[a._v("稍等片刻，会出现如下文件及文件夹：")]),a._v(" "),r("p",[r("img",{attrs:{src:t(354),alt:"aaaa"}})]),a._v(" "),r("p",[a._v("如果以上内容成功出现，恭喜你，Composer 初始化成功！")]),a._v(" "),r("h2",{attrs:{id:"构建路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建路由"}},[a._v("#")]),a._v(" 构建路由")]),a._v(" "),r("p",[a._v("久负盛名的 CodeIgniter 框架是很多人的 PHP 开发入门框架，同样也是我开始学习如何从头构建一个网站的框架。在 CI 中我学到了很多，其中对 MVC 的深入理解和对框架本质的理解对我的影响最大。从使用框架是为了提高开发效率的角度来看，框架的本质就是路由。")]),a._v(" "),r("p",[a._v("下面我们就开始自己来构建路由，先去 GitHub 搜一下："),r("a",{attrs:{href:"https://github.com/search?l=PHP&o=desc&q=router&ref=searchresults&s=stars&type=Repositories&utf8=%E2%9C%93",target:"_blank",rel:"noopener noreferrer"}},[a._v("点此查看搜索结果"),r("OutboundLink")],1)]),a._v(" "),r("p",[a._v("推荐 "),r("a",{attrs:{href:"https://github.com/NoahBuscher/Macaw",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/NoahBuscher/Macaw"),r("OutboundLink")],1),a._v("，对应的 Composer 包为 noahbuscher/macaw 。")]),a._v(" "),r("p",[a._v("下面开始安装它，更改 composer.json：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('{\n  "require": {\n    "noahbuscher/macaw": "dev-master"\n  }\n}\n')])])]),r("p",[a._v("运行 composer update，成功之后将得到以下目录：")]),a._v(" "),r("p",[r("img",{attrs:{src:t(355),alt:""}})]),a._v(" "),r("p",[a._v("至此，Macaw 包安装成功！")]),a._v(" "),r("p",[a._v("下面，就是见证奇迹的时刻！我们将赋予 MFFC 生命力，让它真正地跑起来！")]),a._v(" "),r("p",[a._v("新建 MFFC/public 文件夹，这个文件夹将是用户唯一可见的部分。在文件夹下新建 index.php 文件：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("<?php\n\n// Autoload 自动载入\nrequire '../vendor/autoload.php';\n\n// 路由配置\nrequire '../config/routes.php';\n")])])]),r("p",[a._v("上面一行表示引入 Composer 的自动载入功能，下面一行表示载入路由配置文件。新建 MFFC/config 文件夹，在里面新建 routs.php 文件，内容如下：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("<?php\n\nuse NoahBuscher\\Macaw\\Macaw;\n\nMacaw::get('fuck', function() {\n  echo \"成功！\";\n});\n\nMacaw::get('(:all)', function($fu) {\n  echo '未匹配到路由<br>'.$fu;\n});\n\nMacaw::dispatch();\n\n")])])]),r("p",[a._v("Macaw 的文档位于 "),r("a",{attrs:{href:"https://github.com/NoahBuscher/Macaw",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/NoahBuscher/Macaw"),r("OutboundLink")],1),a._v("，请按照你的 HTTP 服务软件类型自行设置伪静态，其实跟绝大多数框架一样：“将所有非静态文件全部指向 index.php”。")]),a._v(" "),r("p",[a._v("然后，将某一个端口用 Apache 或 Nginx 分配给 MFFC/public 目录，这一步十分建议用 Apache 或者 Nginx 做。")]),a._v(" "),r("p",[a._v("如果使用 PHP 内置 HTTP 服务器：")]),a._v(" "),r("p",[a._v("cd public && php -S 127.0.0.1:3000\n将导致路由的 Macaw::get('fuck' 必须写成 Macaw::get('/fuck' 才能响应。")]),a._v(" "),r("p",[a._v("目前的代码使用 Apache + mod_php 和 Nginx + php-fpm 方式均没有问题。")]),a._v(" "),r("p",[a._v("Macaw 只有一个文件，去除空行总共也就一百行多一点，通过代码我们能直接看明白它是怎么工作的。下面我简略分析一下：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("Composer 的自动加载在每次 URL 驱动 MFFC/public/index.php 之后会在内存中维护一个全量命名空间类名到文件名的数组，这样当我们在代码中使用某个类的时候，将自动载入该类所在的文件。")])]),a._v(" "),r("li",[r("p",[a._v("我们在路由文件中载入了 Macaw 类：“use NoahBuscher\\Macaw\\Macaw;”，接着调用了两次静态方法 ::get()，这个方法是不存在的，将由 MFFC/vendor/codingbean/macaw/Macaw.php 中的 __callstatic() 接管。")])]),a._v(" "),r("li",[r("p",[a._v("这个函数接受两个参数，$method 和 $params，前者是具体的 function 名称，在这里就是 get，后者是这次调用传递的参数，即 Macaw::get('fuck',function(){...}) 中的两个参数。第一个参数是我们想要监听的 URL 值，第二个参数是一个 PHP 闭包，作为回调，代表 URL 匹配成功后我们想要做的事情。")])]),a._v(" "),r("li",[r("p",[a._v("__callstatic() 做的事情也很简单，分别将目标URL（即 /fuck）、HTTP方法（即 GET）和回调代码压入 $routes、$methods 和 $callbacks 三个 Macaw 类的静态成员变量（数组）中。")])]),a._v(" "),r("li",[r("p",[a._v("路由文件最后一行的 Macaw::dispatch(); 方法才是真正处理当前 URL 的地方。能直接匹配到的会直接调用回调，不能直接匹配到的将利用正则进行匹配。")])])]),a._v(" "),r("h3",{attrs:{id:"设计-mvc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计-mvc"}},[a._v("#")]),a._v(" 设计 MVC")]),a._v(" "),r("blockquote",[r("p",[a._v("终于可以 “一次编写，到处发布” 了，泪流满面！")])]),a._v(" "),r("p",[a._v("之前，我们使用 codingbean/macaw 这个 Composer 包构建了两条简单路由，第一条是响应 GET ‘/fuck’ 的，另一条会 hold 住所有请求。其实对 PHP 框架来说，有了路由就有了一切。所以接下来我们要做的事情就是让 MFFC 框架更加规范，更加丰满。")]),a._v(" "),r("p",[a._v("这就牵扯到了 PHP 框架另外的价值：确立开发规范以便于多人协作，使用 ORM、模板引擎 等工具以提高开发效率。")]),a._v(" "),r("p",[r("a",{attrs:{href:"https://lvwenhan.com/php/408.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://lvwenhan.com/php/408.html"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=o.exports}}]);